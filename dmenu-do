#!/usr/bin/env python

# Copyright (C) 2012 Eyal Erez
#
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program; if not,
# write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

import sys
import os
from subprocess import Popen, PIPE
from optparse import OptionParser
from collections import defaultdict
import logging as log

##########
# CONSTS #
##########

## dmenu command
DMENU = ['dmenu', '-i', '-b', '-fn', 'Consolas-10:bold', '-nf', 'grey', '-sb', '#444', '-sf', '#EE9A00']
## List of folders to search, NOTE: must use full path!
FOLDERS = ['~', '/', '~/downloads', '~/notes', '/space', '~/documents']
## List of session commands.  NOTE: You should add this to /etc/sudoers to avoid having to put in a
## password every time.
SESSION = {'shutdown':  'sudo shutdown -h now',
           'reboot':    'sudo shutdown -r now',
           'suspend':   'sudo pm-suspend',
           'hibernate': 'sudo pm-hibernate'}
## File used to store command history info.  Commands are stored in order, most recently used first.
HISTORY_FILE = os.path.join(os.environ['HOME'], ".dmenu-do.history")
## File used to read configuration
CONFIG_FILE = os.path.join(os.environ['HOME'], ".dmenu-do.conf")

#########
# UTILS #
#########
def execute(command,):
  '''Execute command'''
  log.debug('EXECUTE %s' % command)
  os.popen(command + '&')

def is_executable(path):
  '''Is this path an executable file'''
  return os.path.isfile(path) and os.access(path, os.X_OK)

def is_directory(path):
  '''Is this path a directory'''
  return os.path.isdir(path)

##########
# CONFIG #
##########
class Config(object):

  def __init__(self, filename):
    self._filename = filename

  def folders(self):
    '''Get list of search folders'''
    return FOLDERS

  def session(self):
    '''Get session commands'''
    return SESSION

  def executables(self):
    '''Get list of executables based on $PATH'''
    path = os.environ['PATH'].split(':')
    proc = Popen(['lsx-suckless'] + path, stdout=PIPE)
    lines = []
    line = proc.stdout.readline()
    while line:
      lines.append(line.strip())
      line = proc.stdout.readline()
    return lines

############
# LRU DICT #
############
class _LRUDict(object):
  '''An OrderedDict allows a user to add key/value pairs, like a dict, but maintains the order of
  addition.  If an item is added more the once, it will move to the end of the list.  So, the order
  is LRU first.  (Note: this implementation is not thread-safe)
  '''

  def __init__(self):
    '''Create an empty dict'''
    self._d = {}
    self._k = []

  def __len__(self):
    self._dedup()
    return len(self._k)

  def __getitem__(self, key):
    '''Get value'''
    return self._d[key]

  def __setitem__(self, key, value):
    '''Set value'''
    self._k.append(key)
    self._d[key] = value

  def __delitem__(self, key):
    '''Remove item'''
    self._k.remove(key)
    del self._d[key]

  def __contains__(self, key):
    '''Contains key'''
    return key in self._d

  def keys(self):
    '''Return list of keys in order of insertion'''
    self._dedup()
    return self._k

  def items(self):
    '''Return items as a list of (key, value) tuples'''
    self._dedup()
    items = []
    for k in self._k:
      items.append((k, self._d[k]))
    return items

  def _dedup(self):
    '''Remove all key duplicates'''
    # Count the number of duplicates
    dups = defaultdict(int)
    for k in self._k:
      dups[k] += 1
    ks = []
    for k in self._k:
      dups[k] -= 1
      if dups[k] == 0:
        ks.append(k)
    self._k = ks

  def __str__(self):
    s = []
    for k in self._k:
      s.append('%s: %s' % (k, self._d[k]))
    return '{%s}' % ', '.join(s)

###########
# HISTORY #
###########
class History(object):

  TYPE_EXECUTABLE = "EXECUTABLE"
  TYPE_FILE       = "FILE"

  def __init__(self, filename):
    self._filename = filename
    self._commands = _LRUDict()
    try:
      with file(self._filename, 'r') as reader:
        for line in reader:
          line = line.strip()
          if line:
            log.debug('READ HISTORY %s' % line)
            name, command_type, command = line.split(',')
            self._commands[name] = command_type, command
    except IOError:
      pass # file not found, this is fine, we'll just created it later.

  def add_executable(self, command):
    self._commands[command] = (self.TYPE_EXECUTABLE, command)

  def add_file(self, name, path):
    self._commands[name] = (self.TYPE_FILE, path)

  def execute(self, name):
    command_type, command = self._commands[name]
    if self.TYPE_EXECUTABLE == command_type:
      execute(command)
    elif self.TYPE_FILE == command_type:
      execute('see "%s"' % command)
    else:
      raise ValueError('Unknown command type "%s"' % command_type)
    # Pop to first place
    self._commands[name] = command_type, command

  def keys(self):
    return self._commands.keys()

  def __contains__(self, key):
    '''Contains key'''
    return key in self._commands

  def close(self):
    log.debug('WRITING HISTORY %s' % self._filename)
    with file(self._filename, 'w+') as writer:
      for (name, (command_type, command)) in self._commands.items():
        line = "%s,%s,%s\n" % (name, command_type, command)
        log.debug(line)
        writer.write(line)
    log.debug('DONE WRITING HISTORY %s' % self._filename)

#########
# DMENU #
#########
class DMenu(object):

  def __init__(self, config, history):
    self._current = None
    self._config = config
    self._history = history

  def run(self, command=''):
    '''Run the dmenu command recursively'''
    items = []
    # Figure out which items to display
    if command:
      # If current is empty, we are not walking a directory tree.  So, try and see if this is a
      # session command or a path executable.
      if not self._current:
        if command in self._history:
          log.debug('HISTORY: %s' % command)
          # This is a history command, so run it.
          self._history.execute(command)
          return
        if command in self._config.session().keys():
          log.debug('SESSION: %s' % command)
          # This is a session command, so run it.
          execute(self._config.session()[command])
          return
        if command in self._config.executables():
          log.debug('EXECUTABLE: %s' % command)
          self._history.add_executable(command)
          # This is an executable, so run it.
          execute(command)
          return
      # Otherwise, we must be walking a path, so join our current path
      path = os.path.join(self._current, command.replace('~', os.environ['HOME']))
      if is_directory(path):
        log.debug('DIRECTORY: %s' % command)
        # Update current path
        self._current = path
        # This is a directory, so we are going to list all child files and folders.
        items = os.listdir(path)
      elif is_executable(command):
        # This is a full path executable, so run it.
        log.debug('EXECUTABLE: %s' % command)
        execute(command, path)
        return
      else:
        # This is just a file, use mailcap and try to find the right program to run it.
        log.debug('FILE: %s' % path)
        self._history.add_file(command, path)
        execute('see "%s"' % path)
        return
    else:
      # If no command was passed in, show everything
      items = self._history.keys() + \
              self._config.folders() + \
              list(self._config.session().keys()) + \
              sorted(self._config.executables())
    # Open the dmenu command
    proc = Popen(DMENU, shell=False, stdout=PIPE, stdin=PIPE)
    # Run dmenu with the items defined above
    for item in items:
      proc.stdin.write(item)
      proc.stdin.write('\n')
    command = proc.communicate()[0]
    # If we got something back, run dmenu again
    if command:
      self.run(command.strip())

########
# MAIN #
########

def main():
  '''main method'''
  config = Config(CONFIG_FILE)
  history = History(HISTORY_FILE)
  try:
    dmenu = DMenu(config, history)
    dmenu.run()
  finally:
    history.close()

if __name__ == '__main__':
  parser = OptionParser()
  parser.add_option("-v", "--verbose",
                    action="store_true", dest="verbose", default=False,
                    help="print out more information")

  (options, args) = parser.parse_args()

  VERBOSE = options.verbose
  main()
